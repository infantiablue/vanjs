/** @jsx createElement */
/*** @jsxFrag createFragment */
const createElement = (tag, props, ...children) => {
	if (typeof tag === "function") return tag(props, ...children);
	const element = document.createElement(tag);

	Object.entries(props || {}).forEach(([name, value]) => {
		if (name.startsWith("on") && name.toLowerCase() in window) element.addEventListener(name.toLowerCase().substr(2), value);
		else element.setAttribute(name, value.toString());
	});

	children.forEach((child) => {
		appendChild(element, child);
	});

	return element;
};

const appendChild = (parent, child) => {
	if (Array.isArray(child)) child.forEach((nestedChild) => appendChild(parent, nestedChild));
	else parent.appendChild(child.nodeType ? child : document.createTextNode(child));
};

const createFragment = (props, ...children) => {
	return children;
};

/**
 * Detect if DOM has fully loaded
 * @param {Function} callback - The function to run after DOM loaded
 * Source: https://tobiasahlin.com/blog/move-from-jquery-to-vanilla-javascript/
 */
const ready = (callback) => (document.readyState != "loading" ? callback() : document.addEventListener("DOMContentLoaded", callback));
/**
 * Count words from string input, return
 * @param {String} str - The input string
 * @return {number} - The number of words
 */
const countWords = (str) => {
	str = str.trim().replace(/(^\s*)|(\s*$)/gi, "");
	str = str.replace(/[ ]{2,}/gi, " ");
	str = str.replace(/\n /, "\n");
	return str.split(" ").length;
};

/**
 * Get cookie value
 * @param {String} name - The name of desired cookie
 * @return {String} - The value of the cookie
 */
export const getCookie = (name) => {
	let cookieValue = null;
	if (document.cookie && document.cookie !== "") {
		const cookies = document.cookie.split(";");
		for (let i = 0; i < cookies.length; i++) {
			const cookie = cookies[i].trim();
			// Does this cookie string begin with the name we want?
			if (cookie.substring(0, name.length + 1) === name + "=") {
				cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
				break;
			}
		}
	}
	return cookieValue;
};

/**
 * Wrapper of fetch to be used with crsf token, generated by django
 * @param {String} url - Target URL
 * @return {JSON} - Requset params
 */
const djangoCall = async (url = "", data = {}, method = "POST") => {
	// Default options are marked with *
	let options = {
		method: method,
	};
	if (method != "GET" && method != "HEAD") options["body"] = JSON.stringify(data);

	if ((method = "POST")) {
		options.mode = "cors";
		options.headers = {
			"X-CSRFToken": document.querySelector("[name=csrfmiddlewaretoken]").value,
		};
	}
	const response = await fetch(url, options);
	if (response.ok) {
		return response.json();
	} else {
		throw new Error("Something went wrong ...");
	}
};

/**
 * Create simple notification message, with Bootstrap CSS
 * @param {String} msg - The message to display
 * @param {type} msg - Type of mesage to style: success, warning, info, danger, dark
 */
const notify = (msg, type = "success") => {
	// Get the container for notifications to display
	let notifyArea = document.querySelector("#notify");
	// If not existed, create it
	if (!notifyArea) {
		notifyArea = document.createElement("div");
		notifyArea.setAttribute("id", "notify");
		notifyArea.classList.add("notify");
		notifyArea.style.position = "fixed";
		notifyArea.style.top = "3vh";
		if (window.innerWidth < 768) {
			notifyArea.style.width = "100vw";
		} else {
			notifyArea.style.left = "calc(50% - 180px)";
			notifyArea.style.width = "360px";
		}
	}
	// Create individual notification element
	let noti = document.createElement("div");
	noti.classList.add("d-flex", "alert", `alert-${type}`);
	noti.innerHTML = `<span class="flex-grow-1">${msg}</span><button type="button" class="btn-close float-end flex-shrink-0" aria-label="Close"></button>`;
	// Append to the container
	notifyArea.appendChild(noti);
	// Append the container to the body tag
	document.querySelector("body").appendChild(notifyArea);

	// Auto diminish after 2 seconds with effect
	setTimeout(() => {
		noti.classList.add("animate__animated", "animate__fadeOut");
		noti.addEventListener("animationend", () => noti.remove());
	}, 2000);

	// Handle closing button for messages
	let clostBtn = noti.querySelector("button");
	clostBtn.addEventListener("click", () => {
		noti.classList.add("animate__animated", "animate__fadeOut");
		noti.addEventListener("animationend", () => notifyArea.remove());
	});
};

/**
 * Create simple fade in effect, based on animte.css library
 * @param {DOM} elm - The DOM object to be apply effect
 * @param {String} speed - slow (2s), slower (3s), fast(800ms), faster(500ms)
 */
const fadeIn = (elm, speed = "slow") => {
	let effect = ["animate__animated", "animate__fadeIn", `animate__${speed}`];
	elm.classList.add(...effect);
	elm.addEventListener("animationend", () => elm.classList.remove(...effect));
};

/**
 * Create simple fade out effect, based on animte.css library
 * @param {DOM} elm - The DOM object to be apply effect
 * @param {String} speed - slow (2s), slower (3s), fast(800ms), faster(500ms)
 */
const fadeOut = (elm, speed = "slow") => {
	let effect = ["animate__animated", "animate__fadeOut", `animate__${speed}`];
	elm.classList.add(...effect);
	elm.addEventListener("animationend", () => {
		elm.classList.remove(...effect);
		elm.remove();
	});
};

/**
 * Generate random hex color code.
 * @void
 **/
const randomColor = () => "#" + (Math.random() * 0xfffff * 1000000).toString(16).slice(0, 6);

/**
 * Display simple three dots loading without any 3rd party library
 * @param {string} elmID - The ID to load three dots, it should be in a span
 * @param {string} text - Which text to display before three dots
 * @param {string} headingSize - The heading tag wrap the loading span
 * @param {boolean} blink - Toggle the blink effect
 * @param {number} itv - The interval between a dot loading
 * @param {number} dots - The number of dots to load
 * @param {boolean} colorized - Toggle random color dots
 */
const loadingDots = (target, text = "Loading", headingSize = "h3", blink = false, colorized = false, itv = 300, dots = 3) => {
	let container = document.getElementById(target);
	let heading = document.createElement(headingSize);
	let textNode = document.createTextNode(text);
	let loadingSpan = document.createElement("span");
	heading.appendChild(textNode);
	heading.appendChild(loadingSpan);
	container.appendChild(heading);

	const animate = (itv, blink) => {
		loadingSpan.innerHTML = "";
		for (let i = 0; i < dots; i++) {
			if (blink)
				setTimeout(() => {
					loadingSpan.innerHTML = "".repeat(itv * (i + 1));
				}, itv * (i * 2 + 1));
			setTimeout(() => {
				loadingSpan.innerHTML = `<span style="color:${colorized ? randomColor() : "black"}"> . </span>`.repeat(i + 1);
			}, itv * (i * 2 + 2));
		}
	};
	if (container) {
		animate(itv);
		setInterval(() => {
			animate(itv);
		}, itv * (dots * 2 + 1));
	}
};

// const range = (start, end) =>{
// 	return Array.apply(0, Array(end - 1)).map((element, index) => index + start);
// },

export { ready, djangoCall, countWords, notify, fadeIn, fadeOut, createElement, appendChild, createFragment, loadingDots, randomColor };
